<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nexus PM - Integrated</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Babel for in-browser JSX/TS compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body { font-family: 'Inter', sans-serif; }
      ::-webkit-scrollbar { width: 6px; height: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
      ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0",
        "recharts": "https://esm.sh/recharts@2.10.3"
      }
    }
    </script>
</head>
<body class="bg-slate-50 text-slate-900 antialiased">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, createContext, useContext } from 'react';
        import ReactDOM from 'react-dom/client';
        import { 
            LayoutDashboard, KanbanSquare, MessageSquare, Settings, LogOut, Menu, X, 
            Camera, Upload, Check, Bell, CheckCircle2, AtSign, PhoneMissed, Phone, 
            Video, PhoneOff, User as UserIcon, ChevronLeft, ChevronRight,
            Pencil, Plus, CheckSquare, Square, LockKeyhole, Calendar, Clock, Paperclip, 
            Trash2, Send, Minus, FileText, Download, Share2, ChevronDown, ChevronUp, Eye,
            Bookmark, AlertTriangle, Bug, BookOpen, Search, Users, ShieldCheck, Lock, AlertCircle,
            Maximize2, Minimize2, PictureInPicture, UserPlus, Monitor, Mic, MicOff, VideoOff,
            ListTodo, Circle
        } from 'lucide-react';
        import { 
            PieChart, Pie, Cell, ResponsiveContainer, Tooltip as RechartsTooltip, Legend, 
            BarChart, Bar, XAxis, YAxis, CartesianGrid 
        } from 'recharts';

        // --- TYPES ---
        const UserRole = {
            ADMIN: 'ADMIN',
            MEMBER: 'MEMBER'
        };

        const TaskStatus = {
            TODO: 'TODO',
            IN_PROGRESS: 'IN_PROGRESS',
            DONE: 'DONE'
        };

        const TaskCategory = {
            TASK: 'TASK',
            ISSUE: 'ISSUE',
            BUG: 'BUG',
            STORY: 'STORY'
        };

        const NotificationType = {
            MENTION: 'MENTION',
            ASSIGNMENT: 'ASSIGNMENT',
            MISSED_CALL: 'MISSED_CALL',
            SYSTEM: 'SYSTEM'
        };

        // --- CONSTANTS ---
        const INITIAL_PROJECTS = [
            {
                id: 'p1',
                name: 'Website Redesign',
                description: 'Overhaul of the main corporate website with modern stack.',
                memberIds: []
            },
            {
                id: 'p2',
                name: 'Mobile App Launch',
                description: 'Prepare iOS and Android apps for Q4 launch.',
                memberIds: []
            }
        ];

        const INITIAL_USERS = [
            {
                id: 'u1',
                name: 'Admin User',
                username: 'admin',
                password: 'admin123',
                role: UserRole.ADMIN,
                avatar: 'https://api.dicebear.com/9.x/avataaars/svg?seed=Felix',
                isOnline: true,
                projectAccess: { 'p1': 'write', 'p2': 'write' }
            },
            {
                id: 'u2',
                name: 'Sarah Engineer',
                username: 'sarah',
                password: 'password',
                role: UserRole.MEMBER,
                avatar: 'https://api.dicebear.com/9.x/avataaars/svg?seed=Aneka',
                isOnline: true,
                projectAccess: { 'p1': 'write', 'p2': 'read' }
            },
            {
                id: 'u3',
                name: 'Mike Designer',
                username: 'mike',
                password: 'password',
                role: UserRole.MEMBER,
                avatar: 'https://api.dicebear.com/9.x/avataaars/svg?seed=Scooter',
                isOnline: false,
                projectAccess: { 'p1': 'read', 'p2': 'none' }
            }
        ];

        const INITIAL_TASKS = [
            {
                id: 't1',
                projectId: 'p1',
                title: 'Setup React Repo',
                description: 'Initialize the project with Vite, TypeScript and Tailwind.',
                status: TaskStatus.DONE,
                category: TaskCategory.TASK,
                assigneeId: 'u2',
                priority: 'high',
                dueDate: '2023-12-01',
                createdAt: Date.now() - 10000000,
                attachments: [],
                comments: [],
                subtasks: [
                    { id: 'st1', title: 'Install dependencies', completed: true, status: TaskStatus.DONE, category: TaskCategory.TASK, description: 'Run npm install', priority: 'medium', attachments: [], comments: [], createdAt: Date.now() },
                    { id: 'st2', title: 'Configure ESLint', completed: true, status: TaskStatus.DONE, category: TaskCategory.TASK, description: 'Standard config', priority: 'low', attachments: [], comments: [], createdAt: Date.now() }
                ]
            },
            {
                id: 't2',
                projectId: 'p1',
                title: 'Design Home Page',
                description: 'Create Figma mockups for the landing page hero section.',
                status: TaskStatus.IN_PROGRESS,
                category: TaskCategory.STORY,
                assigneeId: 'u3',
                priority: 'medium',
                dueDate: '2023-12-15',
                createdAt: Date.now() - 5000000,
                attachments: [{ id: 'a1', name: 'hero_v1.png', size: '2.4 MB', type: 'image/png' }],
                comments: [],
                subtasks: []
            },
            {
                id: 't3',
                projectId: 'p1',
                title: 'Integrate API',
                description: 'Connect frontend to the backend GraphQL endpoints.',
                status: TaskStatus.TODO,
                category: TaskCategory.TASK,
                assigneeId: 'u2',
                priority: 'high',
                dueDate: '2023-12-20',
                createdAt: Date.now() - 1000000,
                attachments: [],
                comments: [],
                subtasks: []
            },
            {
                id: 't4',
                projectId: 'p1',
                title: 'Fix Login Crash',
                description: 'App crashes on Safari when clicking login button.',
                status: TaskStatus.TODO,
                category: TaskCategory.BUG,
                assigneeId: 'u2',
                priority: 'high',
                dueDate: '2023-12-10',
                createdAt: Date.now() - 200000,
                attachments: [],
                comments: [],
                subtasks: []
            }
        ];

        // --- COMPONENTS ---
        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
                <div className="bg-white rounded-xl shadow-xl w-full max-w-lg overflow-hidden animate-in fade-in zoom-in duration-200">
                    <div className="flex items-center justify-between p-4 border-b border-gray-100">
                    <h3 className="text-lg font-semibold text-gray-800">{title}</h3>
                    <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded-full transition-colors">
                        <X size={20} className="text-gray-500" />
                    </button>
                    </div>
                    <div className="p-4 max-h-[80vh] overflow-y-auto">
                    {children}
                    </div>
                </div>
                </div>
            );
        };

        // --- STORE ---
        const AppContext = createContext(undefined);
        const RTC_CONFIG = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' }
            ]
        };

        const AppProvider = ({ children }) => {
            const [currentUser, setCurrentUser] = useState(null);
            const [users, setUsers] = useState(INITIAL_USERS);
            const [projects, setProjects] = useState(INITIAL_PROJECTS);
            const [tasks, setTasks] = useState(INITIAL_TASKS);
            const [messages, setMessages] = useState([]);
            const [groups, setGroups] = useState([]);
            const [notifications, setNotifications] = useState([]);
            
            const [incomingCall, setIncomingCall] = useState(null);
            const [isInCall, setIsInCall] = useState(false);
            const [activeCallData, setActiveCallData] = useState(null);
            
            const [localStream, setLocalStream] = useState(null);
            const [remoteStreams, setRemoteStreams] = useState(new Map());
            
            const [isScreenSharing, setIsScreenSharing] = useState(false);
            const [isMicOn, setIsMicOn] = useState(false);
            const [isCameraOn, setIsCameraOn] = useState(false);

            const peerConnectionsRef = useRef(new Map());
            const signalingChannelRef = useRef(null);
            const localVideoTrackRef = useRef(null); 
            const [lastReadTimestamps, setLastReadTimestamps] = useState({});

            // Signaling
            useEffect(() => {
                signalingChannelRef.current = new BroadcastChannel('nexus-signaling');
                signalingChannelRef.current.onmessage = async (event) => {
                    const { type, senderId, recipientId, payload } = event.data;
                    if (!currentUser) return;
                    if (recipientId && recipientId !== currentUser.id && type !== 'USER_ONLINE') return;

                    switch (type) {
                        case 'CHAT_MSG':
                            setMessages(prev => {
                                if (prev.find(m => m.id === payload.id)) return prev;
                                return [...prev, payload];
                            });
                            break;
                        case 'USER_ONLINE':
                            setUsers(prev => prev.map(u => u.id === senderId ? { ...u, isOnline: true } : u));
                            break;
                        case 'OFFER':
                            if (isInCall) return;
                            setIncomingCall({ callerId: senderId, isVideo: payload.isVideo, timestamp: Date.now(), offer: payload.sdp });
                            break;
                        case 'ANSWER':
                            {
                                const pc = peerConnectionsRef.current.get(senderId);
                                if (pc) {
                                    await pc.setRemoteDescription(new RTCSessionDescription(payload.sdp));
                                    setActiveCallData(prev => {
                                        if (!prev) return null;
                                        if (prev.participantIds.includes(senderId)) return prev;
                                        return { ...prev, participantIds: [...prev.participantIds, senderId] };
                                    });
                                }
                            }
                            break;
                        case 'CANDIDATE':
                            {
                                const pc = peerConnectionsRef.current.get(senderId);
                                if (pc && payload.candidate) {
                                    try { await pc.addIceCandidate(new RTCIceCandidate(payload.candidate)); } catch (e) { console.error(e); }
                                }
                            }
                            break;
                        case 'HANGUP':
                            handleRemoteHangup(senderId);
                            break;
                    }
                };
                return () => signalingChannelRef.current?.close();
            }, [currentUser, isInCall]);

            const sendSignal = (type, recipientId, payload) => {
                if (signalingChannelRef.current && currentUser) {
                    signalingChannelRef.current.postMessage({ type, senderId: currentUser.id, recipientId, payload });
                }
            };

            const login = (user) => {
                setCurrentUser(user);
                setTimeout(() => {
                    if(signalingChannelRef.current) signalingChannelRef.current.postMessage({ type: 'USER_ONLINE', senderId: user.id, payload: {} });
                }, 500);
            };

            const logout = () => {
                setCurrentUser(null);
                setNotifications([]);
                setLastReadTimestamps({});
                setIncomingCall(null);
                setIsInCall(false);
                cleanupCall();
            };

            const addUser = (user) => setUsers([...users, user]);
            const updateUser = (u) => {
                setUsers(users.map(existing => existing.id === u.id ? u : existing));
                if (currentUser?.id === u.id) setCurrentUser(u);
            };
            const deleteUser = (id) => setUsers(users.filter(u => u.id !== id));
            const addTask = (t) => setTasks([...tasks, t]);
            const updateTask = (t) => setTasks(tasks.map(existing => existing.id === t.id ? t : existing));
            const moveTask = (id, s) => setTasks(prev => prev.map(t => t.id === id ? { ...t, status: s } : t));
            
            const addMessage = (text, recipientId, attachments = []) => {
                if (!currentUser) return;
                const newMsg = { id: Date.now().toString() + Math.random(), senderId: currentUser.id, recipientId, text, timestamp: Date.now(), type: 'text', attachments };
                setMessages([...messages, newMsg]);
                const chatId = recipientId || 'general';
                setLastReadTimestamps(prev => ({ ...prev, [chatId]: Date.now() }));
                sendSignal('CHAT_MSG', recipientId, newMsg);
            };

            const createGroup = (name, memberIds) => {
                if (!currentUser) return;
                const allMembers = Array.from(new Set([...memberIds, currentUser.id]));
                setGroups([...groups, { id: 'g-' + Date.now(), name, memberIds: allMembers, createdAt: Date.now(), createdBy: currentUser.id }]);
            };

            const addProject = (name, description) => {
                const newProjectId = 'p-' + Date.now();
                setProjects([...projects, { id: newProjectId, name, description, memberIds: [] }]);
                if (currentUser) {
                    updateUser({ ...currentUser, projectAccess: { ...currentUser.projectAccess, [newProjectId]: 'write' } });
                }
            };

            const triggerNotification = (recipientId, type, title, message, linkTo) => {
                if (currentUser && recipientId === currentUser.id) return;
                setNotifications(prev => [{ id: 'n-' + Date.now() + Math.random(), recipientId, senderId: currentUser?.id, type, title, message, timestamp: Date.now(), read: false, linkTo }, ...prev]);
            };

            const markNotificationRead = (id) => setNotifications(prev => prev.map(n => n.id === id ? { ...n, read: true } : n));
            const clearNotifications = () => { if (!currentUser) return; setNotifications(prev => prev.map(n => n.recipientId === currentUser.id ? { ...n, read: true } : n)); };
            const markChatRead = (chatId) => setLastReadTimestamps(prev => ({ ...prev, [chatId]: Date.now() }));
            
            const getUnreadCount = (chatId) => {
                if (!currentUser) return 0;
                const lastRead = lastReadTimestamps[chatId] || 0;
                return messages.filter(m => {
                    const isRelevant = (chatId !== 'general' && !chatId.startsWith('g-') && m.senderId === chatId && m.recipientId === currentUser.id) ||
                                     (chatId.startsWith('g-') && m.recipientId === chatId && m.senderId !== currentUser.id) ||
                                     (chatId === 'general' && !m.recipientId && m.senderId !== currentUser.id);
                    return isRelevant && m.timestamp > lastRead;
                }).length;
            };

            const totalUnreadChatCount = React.useMemo(() => {
                if (!currentUser) return 0;
                let count = getUnreadCount('general');
                groups.forEach(g => { if (g.memberIds.includes(currentUser.id)) count += getUnreadCount(g.id); });
                users.forEach(u => { if (u.id !== currentUser.id) count += getUnreadCount(u.id); });
                return count;
            }, [messages, lastReadTimestamps, currentUser, groups, users]);

            // WebRTC Helpers
            const createPeerConnection = (recipientId) => {
                const pc = new RTCPeerConnection(RTC_CONFIG);
                pc.onicecandidate = (event) => {
                    if (event.candidate) sendSignal('CANDIDATE', recipientId, { candidate: event.candidate.toJSON() });
                };
                pc.ontrack = (event) => {
                    setRemoteStreams(prev => { const newMap = new Map(prev); newMap.set(recipientId, event.streams[0]); return newMap; });
                };
                peerConnectionsRef.current.set(recipientId, pc);
                return pc;
            };

            const toggleMic = async () => {
                if (!localStream) return;
                if (isMicOn) {
                    localStream.getAudioTracks().forEach(t => t.stop());
                    setIsMicOn(false);
                    peerConnectionsRef.current.forEach(pc => {
                        const sender = pc.getSenders().find(s => s.track?.kind === 'audio');
                        if (sender) sender.replaceTrack(null);
                    });
                } else {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        const audioTrack = stream.getAudioTracks()[0];
                        localStream.getAudioTracks().forEach(t => { t.stop(); localStream.removeTrack(t); });
                        localStream.addTrack(audioTrack);
                        for (const pc of peerConnectionsRef.current.values()) {
                            const sender = pc.getSenders().find(s => s.track?.kind === 'audio');
                            if (sender) await sender.replaceTrack(audioTrack);
                            else pc.addTrack(audioTrack, localStream);
                        }
                        setIsMicOn(true);
                    } catch (e) { console.error("Mic error", e); }
                }
            };

            const toggleCamera = async () => {
                if (!localStream) return;
                if (isScreenSharing) { setIsCameraOn(!isCameraOn); return; }
                if (isCameraOn) {
                    localStream.getVideoTracks().forEach(track => { track.stop(); localStream.removeTrack(track); });
                    peerConnectionsRef.current.forEach(pc => {
                        const sender = pc.getSenders().find(s => s.track?.kind === 'video');
                        if (sender) sender.replaceTrack(null);
                    });
                    setIsCameraOn(false);
                    setLocalStream(new MediaStream(localStream.getTracks()));
                } else {
                    try {
                        const newStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        const newVideoTrack = newStream.getVideoTracks()[0];
                        localStream.addTrack(newVideoTrack);
                        for (const pc of peerConnectionsRef.current.values()) {
                            const sender = pc.getSenders().find(s => s.track?.kind === 'video');
                            if (sender) await sender.replaceTrack(newVideoTrack);
                            else pc.addTrack(newVideoTrack, localStream);
                        }
                        setIsCameraOn(true);
                        setLocalStream(new MediaStream(localStream.getTracks()));
                    } catch (e) { console.error("Camera error", e); alert("Camera error"); }
                }
            };

            const startCall = async (recipientId, isVideo) => { await startGroupCall([recipientId], isVideo); };

            const startGroupCall = async (recipientIds, isVideo) => {
                if (!currentUser || recipientIds.length === 0) return;
                let stream = localStream;
                if (!stream) {
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ video: isVideo, audio: true });
                        setIsMicOn(true); setIsCameraOn(isVideo);
                    } catch (e) {
                        try {
                            stream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
                            setIsMicOn(true); setIsCameraOn(false);
                        } catch(e2) { console.error("Media error"); return; }
                    }
                    setLocalStream(stream);
                }
                setIsInCall(true);
                setActiveCallData({ participantIds: recipientIds, isVideo });
                recipientIds.forEach(async (recipientId) => {
                    try {
                        const pc = createPeerConnection(recipientId);
                        stream.getTracks().forEach(track => pc.addTrack(track, stream));
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        sendSignal('OFFER', recipientId, { sdp: { type: offer.type, sdp: offer.sdp }, isVideo });
                    } catch(e) { console.error(`Failed to call ${recipientId}`, e); }
                });
            };

            const addToCall = async (recipientId) => {
                if (!currentUser || !isInCall || !activeCallData) return;
                // Simplified for brevity - assumes stream exists
                const pc = createPeerConnection(recipientId);
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal('OFFER', recipientId, { sdp: { type: offer.type, sdp: offer.sdp }, isVideo: activeCallData.isVideo });
                setActiveCallData(prev => prev ? { ...prev, participantIds: [...prev.participantIds, recipientId] } : null);
            };

            const acceptIncomingCall = async () => {
                if (!incomingCall || !currentUser) return;
                try {
                    let stream;
                    try { stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true }); setIsMicOn(true); setIsCameraOn(true); }
                    catch (e) { stream = await navigator.mediaDevices.getUserMedia({ video: false, audio: true }); setIsMicOn(true); setIsCameraOn(false); }
                    setLocalStream(stream);
                    const pc = createPeerConnection(incomingCall.callerId);
                    stream.getTracks().forEach(track => pc.addTrack(track, stream));
                    if (incomingCall.offer) {
                        await pc.setRemoteDescription(new RTCSessionDescription(incomingCall.offer));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        sendSignal('ANSWER', incomingCall.callerId, { sdp: { type: answer.type, sdp: answer.sdp } });
                    }
                    setIsInCall(true);
                    setActiveCallData({ participantIds: [incomingCall.callerId], isVideo: incomingCall.isVideo });
                    setIncomingCall(null);
                } catch (err) { console.error("Accept error", err); }
            };

            const rejectIncomingCall = () => { if (incomingCall) { sendSignal('HANGUP', incomingCall.callerId, {}); setIncomingCall(null); } };
            const endCall = () => {
                if (activeCallData) activeCallData.participantIds.forEach(pid => sendSignal('HANGUP', pid, {}));
                cleanupCall();
            };

            const handleRemoteHangup = (senderId) => {
                const pc = peerConnectionsRef.current.get(senderId);
                if (pc) { pc.close(); peerConnectionsRef.current.delete(senderId); }
                setRemoteStreams(prev => { const newMap = new Map(prev); newMap.delete(senderId); return newMap; });
                setActiveCallData(prev => {
                    if (!prev) return null;
                    const newIds = prev.participantIds.filter(id => id !== senderId);
                    if (newIds.length === 0) { cleanupCall(); return null; }
                    return { ...prev, participantIds: newIds };
                });
            };

            const cleanupCall = () => {
                if (localStream) localStream.getTracks().forEach(track => track.stop());
                peerConnectionsRef.current.forEach(pc => pc.close());
                peerConnectionsRef.current.clear();
                setLocalStream(null);
                setRemoteStreams(new Map());
                setIsInCall(false);
                setActiveCallData(null);
                setIsScreenSharing(false);
                setIsMicOn(false);
                setIsCameraOn(false);
            };

            const toggleScreenShare = async () => {
                if (peerConnectionsRef.current.size === 0 || !localStream) return;
                if (isScreenSharing) {
                    // Stop sharing - simplistic revert
                    if (isCameraOn) await toggleCamera(); // Re-trigger camera
                    setIsScreenSharing(false);
                } else {
                    try {
                        const displayStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                        const screenTrack = displayStream.getVideoTracks()[0];
                        if (isCameraOn) localStream.getVideoTracks().forEach(t => t.stop());
                        localStream.addTrack(screenTrack);
                        for (const pc of peerConnectionsRef.current.values()) {
                            const sender = pc.getSenders().find(s => s.track?.kind === 'video');
                            if (sender) await sender.replaceTrack(screenTrack);
                        }
                        setIsScreenSharing(true);
                        setLocalStream(new MediaStream(localStream.getTracks()));
                        screenTrack.onended = () => { setIsScreenSharing(false); toggleCamera(); };
                    } catch(e) { console.error(e); }
                }
            };

            return (
                <AppContext.Provider value={{
                    currentUser, users, projects, tasks, messages, groups, notifications,
                    incomingCall, isInCall, activeCallData, localStream, remoteStreams, isScreenSharing,
                    isMicOn, isCameraOn, toggleMic, toggleCamera, toggleScreenShare,
                    login, logout, addUser, updateUser, deleteUser, addTask, updateTask, moveTask,
                    addMessage, createGroup, addProject, triggerNotification, markNotificationRead,
                    clearNotifications, markChatRead, getUnreadCount, totalUnreadChatCount,
                    startCall, startGroupCall, addToCall, acceptIncomingCall, rejectIncomingCall, endCall
                }}>
                    {children}
                </AppContext.Provider>
            );
        };

        const useApp = () => {
            const context = useContext(AppContext);
            if (!context) throw new Error("useApp must be used within AppProvider");
            return context;
        };

        // --- MODULE: LOGIN ---
        const Login = () => {
            const { login, users } = useApp();
            const [role, setRole] = useState(UserRole.MEMBER);
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleLogin = (e) => {
                e.preventDefault();
                setError('');
                const user = users.find(u => u.username === username && u.password === password);
                if (user) {
                    if (user.role !== role) { setError(`Account is not ${role === UserRole.ADMIN ? 'Admin' : 'Member'}.`); return; }
                    login(user);
                } else { setError('Invalid credentials.'); }
            };

            return (
                <div className="min-h-screen bg-slate-100 flex items-center justify-center p-4">
                    <div className="bg-white rounded-2xl shadow-xl w-full max-w-md overflow-hidden animate-in fade-in zoom-in duration-300">
                        <div className="bg-indigo-600 p-8 text-center"><h1 className="text-3xl font-bold text-white mb-2">Nexus PM</h1><p className="text-indigo-100">Project Management Simplified</p></div>
                        <div className="p-8">
                            <div className="flex bg-slate-100 p-1 rounded-lg mb-8">
                                <button onClick={() => {setRole(UserRole.MEMBER);setError('');}} className={`flex-1 flex items-center justify-center py-2 rounded-md text-sm font-medium transition-all ${role === UserRole.MEMBER ? 'bg-white shadow text-indigo-600' : 'text-slate-500'}`}><UserIcon size={16} className="mr-2"/> Member</button>
                                <button onClick={() => {setRole(UserRole.ADMIN);setError('');}} className={`flex-1 flex items-center justify-center py-2 rounded-md text-sm font-medium transition-all ${role === UserRole.ADMIN ? 'bg-white shadow text-indigo-600' : 'text-slate-500'}`}><ShieldCheck size={16} className="mr-2"/> Admin</button>
                            </div>
                            <form onSubmit={handleLogin} className="space-y-4">
                                <div><label className="block text-sm font-medium text-slate-700 mb-1">Username</label><input type="text" value={username} onChange={e => setUsername(e.target.value)} className="w-full px-4 py-2 border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder={role===UserRole.ADMIN?"admin":"sarah"}/></div>
                                <div><label className="block text-sm font-medium text-slate-700 mb-1">Password</label><div className="relative"><input type="password" value={password} onChange={e => setPassword(e.target.value)} className="w-full px-4 py-2 border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="••••••••"/><Lock size={16} className="absolute right-3 top-3 text-slate-400"/></div></div>
                                {error && <div className="flex items-center text-red-500 text-sm bg-red-50 p-2 rounded-lg"><AlertCircle size={16} className="mr-2 shrink-0"/>{error}</div>}
                                <button type="submit" className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2.5 rounded-lg transition-colors shadow-lg shadow-indigo-200">Login</button>
                            </form>
                            <div className="mt-6 text-center text-xs text-slate-400"><p>Admin: admin / admin123</p><p>Member: sarah / password</p></div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- MODULE: DASHBOARD ---
        const Dashboard = () => {
            const { tasks, currentUser } = useApp();
            const total = tasks.length;
            const done = tasks.filter(t => t.status === TaskStatus.DONE).length;
            const prog = tasks.filter(t => t.status === TaskStatus.IN_PROGRESS).length;
            const todo = tasks.filter(t => t.status === TaskStatus.TODO).length;
            const data = [{ name: 'To Do', value: todo, color: '#94a3b8' }, { name: 'In Progress', value: prog, color: '#3b82f6' }, { name: 'Done', value: done, color: '#22c55e' }];
            const actData = [{ name: 'Mon', tasks: 4 }, { name: 'Tue', tasks: 3 }, { name: 'Wed', tasks: 7 }, { name: 'Thu', tasks: 2 }, { name: 'Fri', tasks: 5 }];

            return (
                <div className="p-6 space-y-6 animate-in fade-in duration-500">
                    <div className="flex justify-between items-center"><h1 className="text-2xl font-bold text-slate-800">Dashboard</h1><div className="text-sm text-slate-500">Welcome, {currentUser?.name}</div></div>
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-100 flex items-center space-x-4"><div className="p-3 bg-indigo-50 text-indigo-600 rounded-lg"><ListTodo size={24}/></div><div><p className="text-slate-500 text-sm">Total Tasks</p><h3 className="text-2xl font-bold text-slate-800">{total}</h3></div></div>
                        <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-100 flex items-center space-x-4"><div className="p-3 bg-blue-50 text-blue-600 rounded-lg"><Clock size={24}/></div><div><p className="text-slate-500 text-sm">In Progress</p><h3 className="text-2xl font-bold text-slate-800">{prog}</h3></div></div>
                        <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-100 flex items-center space-x-4"><div className="p-3 bg-green-50 text-green-600 rounded-lg"><CheckCircle2 size={24}/></div><div><p className="text-slate-500 text-sm">Completed</p><h3 className="text-2xl font-bold text-slate-800">{done}</h3></div></div>
                        <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-100 flex items-center space-x-4"><div className="p-3 bg-slate-50 text-slate-600 rounded-lg"><Circle size={24}/></div><div><p className="text-slate-500 text-sm">Pending</p><h3 className="text-2xl font-bold text-slate-800">{todo}</h3></div></div>
                    </div>
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-100"><h3 className="text-lg font-semibold text-slate-800 mb-4">Task Distribution</h3><div className="h-64"><ResponsiveContainer width="100%" height="100%"><PieChart><Pie data={data} cx="50%" cy="50%" innerRadius={60} outerRadius={80} paddingAngle={5} dataKey="value">{data.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.color} />))}</Pie><RechartsTooltip /><Legend /></PieChart></ResponsiveContainer></div></div>
                        <div className="bg-white p-6 rounded-xl shadow-sm border border-slate-100"><h3 className="text-lg font-semibold text-slate-800 mb-4">Weekly Productivity</h3><div className="h-64"><ResponsiveContainer width="100%" height="100%"><BarChart data={actData}><CartesianGrid strokeDasharray="3 3" vertical={false} /><XAxis dataKey="name" axisLine={false} tickLine={false} /><YAxis axisLine={false} tickLine={false} /><RechartsTooltip cursor={{ fill: '#f1f5f9' }} /><Bar dataKey="tasks" fill="#6366f1" radius={[4, 4, 0, 0]} barSize={32} /></BarChart></ResponsiveContainer></div></div>
                    </div>
                </div>
            );
        };

        // --- MODULE: KANBAN ---
        const CATEGORY_STYLES = {
          [TaskCategory.TASK]: { label: 'Task', color: 'bg-slate-100 text-slate-700 border-slate-200', icon: CheckCircle2 },
          [TaskCategory.ISSUE]: { label: 'Issue', color: 'bg-amber-100 text-amber-700 border-amber-200', icon: AlertTriangle },
          [TaskCategory.BUG]: { label: 'Bug', color: 'bg-red-100 text-red-700 border-red-200', icon: Bug },
          [TaskCategory.STORY]: { label: 'Story', color: 'bg-green-100 text-green-700 border-green-200', icon: BookOpen },
        };

        const TaskCardItem = ({ task, users, canEdit, onEditTask, onEditSubtask, onUpdateTask, onDragStart }) => {
            const [isExpanded, setIsExpanded] = useState(false);
            const [isAssigning, setIsAssigning] = useState(false);
            const assigneeRef = useRef(null);
            
            const assignee = users.find(u => u.id === task.assigneeId);
            const cat = CATEGORY_STYLES[task.category] || CATEGORY_STYLES[TaskCategory.TASK];
            
            useEffect(() => {
                const handleClickOutside = (event) => { if (assigneeRef.current && !assigneeRef.current.contains(event.target)) setIsAssigning(false); };
                if (isAssigning) document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [isAssigning]);

            const handleAssign = (userId) => { onUpdateTask({ ...task, assigneeId: userId }); setIsAssigning(false); };

            return (
                <div draggable={canEdit} onDragStart={(e) => onDragStart(e, task.id)} className={`bg-white p-4 rounded-lg shadow-sm border border-slate-100 transition-all group relative ${canEdit ? 'cursor-grab active:cursor-grabbing hover:shadow-md hover:border-indigo-200' : 'opacity-90'} ${isAssigning ? 'z-20 ring-1 ring-indigo-200 shadow-md' : 'z-0'}`}>
                    <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center space-x-2"><span className={`px-2 py-0.5 rounded text-[10px] font-bold uppercase border flex items-center ${cat.color}`}>{cat.label}</span><span className="px-2 py-0.5 rounded text-[10px] font-medium border bg-slate-50 border-slate-100 text-slate-600">{task.priority}</span></div>
                        <div className="flex items-center space-x-1">
                            <button onClick={(e) => { e.stopPropagation(); setIsExpanded(!isExpanded); }} className="p-1 rounded hover:bg-slate-50 text-slate-400 hover:text-indigo-600">{isExpanded ? <ChevronUp size={14} /> : <ChevronDown size={14} />}</button>
                            <button onClick={(e) => { e.stopPropagation(); onEditTask(task); }} className="p-1 rounded hover:bg-slate-50 text-slate-400 hover:text-indigo-600">{canEdit ? <Pencil size={14} /> : <Eye size={14} />}</button>
                        </div>
                    </div>
                    <h4 className="font-medium text-slate-800 mb-1">{task.title}</h4>
                    {isExpanded && <p className="text-xs text-slate-600 mb-3 whitespace-pre-wrap">{task.description}</p>}
                    <div className="flex items-center space-x-3 mb-3">
                         {task.subtasks.length > 0 && <div className="flex items-center text-xs text-slate-400"><CheckSquare size={12} className="mr-1"/> {task.subtasks.filter(s=>s.completed).length}/{task.subtasks.length}</div>}
                         {task.attachments?.length > 0 && <div className="flex items-center text-xs text-slate-400"><Paperclip size={12} className="mr-1"/> {task.attachments.length}</div>}
                    </div>
                    {isExpanded && task.subtasks.length > 0 && (
                        <div className="mb-3 pt-2 border-t border-slate-50 space-y-2">
                            {task.subtasks.map(sub => (
                                <div key={sub.id} className="flex items-center justify-between group/sub">
                                    <button onClick={(e)=>{e.stopPropagation();if(canEdit){const up=task.subtasks.map(s=>s.id===sub.id?{...s,completed:!s.completed}:s);onUpdateTask({...task,subtasks:up});}}} className={`mr-2 ${sub.completed?'text-green-500':'text-slate-300'} ${canEdit?'hover:text-indigo-500':''}`} disabled={!canEdit}>{sub.completed?<CheckSquare size={14}/>:<Square size={14}/>}</button>
                                    <span className={`text-xs flex-1 truncate ${sub.completed?'line-through text-slate-400':'text-slate-600'}`}>{sub.title}</span>
                                    <button onClick={(e)=>{e.stopPropagation();onEditSubtask(task,sub);}} className="text-slate-300 hover:text-indigo-600 opacity-0 group-hover/sub:opacity-100 transition-opacity">{canEdit?<Pencil size={12}/>:<Eye size={12}/>}</button>
                                </div>
                            ))}
                        </div>
                    )}
                    <div className="flex justify-between items-center mt-2 pt-2 border-t border-slate-50 relative">
                        <div ref={assigneeRef} className="relative">
                            <button onClick={(e)=>{e.stopPropagation(); if(canEdit) setIsAssigning(!isAssigning);}} className={`flex items-center ${canEdit?'hover:bg-slate-50 rounded p-1 -ml-1':''}`}>
                                {assignee ? <><img src={assignee.avatar} className="w-6 h-6 rounded-full mr-2 object-cover border border-slate-200"/><span className="text-xs text-slate-500 font-medium">{assignee.name.split(' ')[0]}</span></> : <><div className="w-6 h-6 rounded-full bg-slate-100 flex items-center justify-center mr-2 border border-slate-200"><UserIcon size={12} className="text-slate-400"/></div><span className="text-xs text-slate-400">Unassigned</span></>}
                            </button>
                            {isAssigning && (
                                <div className="absolute left-0 top-full mt-2 w-56 bg-white rounded-xl shadow-xl border border-slate-100 z-50 max-h-64 overflow-y-auto flex flex-col p-1">
                                    <div className="px-2 py-1.5 text-[10px] font-bold text-slate-400 uppercase border-b border-slate-50">Assign To</div>
                                    <button onClick={(e)=>{e.stopPropagation();handleAssign(undefined);}} className="w-full text-left flex items-center px-2 py-2 hover:bg-red-50 hover:text-red-600 rounded-lg text-xs text-slate-500"><X size={14} className="mr-3"/> Unassigned</button>
                                    {users.map(u => (
                                        <button key={u.id} onClick={(e)=>{e.stopPropagation();handleAssign(u.id);}} className="w-full text-left flex items-center px-2 py-2 hover:bg-slate-50 rounded-lg text-slate-700">
                                            <img src={u.avatar} className="w-6 h-6 rounded-full mr-3"/><span className="text-xs font-medium">{u.name}</span>
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                        <span className="text-xs text-slate-300 font-mono">#{task.id.slice(-4)}</span>
                    </div>
                </div>
            );
        };

        const KanbanBoard = () => {
            const { tasks, projects, moveTask, updateTask, users, currentUser, addProject } = useApp();
            const accessibleProjects = projects.filter(p => currentUser?.projectAccess[p.id] && currentUser.projectAccess[p.id] !== 'none');
            const [activeProjectId, setActiveProjectId] = useState(accessibleProjects[0]?.id || '');
            const [editingTask, setEditingTask] = useState(null);
            const [isNewTaskModalOpen, setIsNewTaskModalOpen] = useState(false);
            const [isNewProjectModalOpen, setIsNewProjectModalOpen] = useState(false);
            const [newProjectName, setNewProjectName] = useState('');
            const [newProjectDescription, setNewProjectDescription] = useState('');

            useEffect(() => {
                if (accessibleProjects.length > 0 && !accessibleProjects.find(p => p.id === activeProjectId)) setActiveProjectId(accessibleProjects[0].id);
            }, [accessibleProjects, activeProjectId]);

            const canEdit = currentUser?.projectAccess[activeProjectId] === 'write';
            const projectTasks = tasks.filter(t => t.projectId === activeProjectId);

            const onDrop = (e, status) => {
                e.preventDefault(); if (!canEdit) return;
                const taskId = e.dataTransfer.getData('taskId');
                if (taskId) moveTask(taskId, status);
            };

            const Column = ({ title, status, tasks }) => (
                <div onDragOver={(e)=>{e.preventDefault();}} onDrop={(e)=>onDrop(e, status)} className="bg-slate-50/50 p-4 rounded-xl min-h-[500px] flex flex-col border border-slate-100">
                    <div className="flex justify-between items-center mb-4"><h3 className="font-semibold text-slate-700">{title}</h3><span className="text-xs bg-white px-2 py-1 rounded border border-slate-200">{tasks.length}</span></div>
                    <div className="space-y-3 flex-1">
                        {tasks.map(t => <TaskCardItem key={t.id} task={t} users={users} canEdit={canEdit} onEditTask={setEditingTask} onEditSubtask={()=>{}} onUpdateTask={updateTask} onDragStart={(e,id)=>{e.dataTransfer.setData('taskId', id);}} />)}
                    </div>
                </div>
            );

            if (accessibleProjects.length === 0 && currentUser?.role !== UserRole.ADMIN) return <div className="text-center p-8 text-slate-400">No Projects Accessible</div>;

            return (
                <div className="p-6 h-full flex flex-col relative">
                    <div className="flex justify-between items-center mb-6">
                        <div>
                            <h1 className="text-2xl font-bold text-slate-800">Projects</h1>
                            <div className="flex gap-2 mt-2">{accessibleProjects.map(p=><button key={p.id} onClick={()=>setActiveProjectId(p.id)} className={`px-3 py-1 rounded-full text-sm border ${activeProjectId===p.id?'bg-indigo-600 text-white':'bg-white text-slate-600'}`}>{p.name}</button>)}
                            {currentUser?.role === UserRole.ADMIN && <button onClick={()=>setIsNewProjectModalOpen(true)} className="px-3 py-1 rounded-full text-sm border border-dashed border-slate-300 text-slate-500 hover:text-indigo-600"><Plus size={14} className="inline"/> New</button>}</div>
                        </div>
                        {canEdit && <button onClick={()=>setIsNewTaskModalOpen(true)} className="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg flex items-center"><Plus size={18} className="mr-2"/> New Task</button>}
                    </div>
                    {accessibleProjects.length === 0 ? <div className="text-center p-8 border-2 border-dashed border-slate-200 rounded-xl"><p>Create a project to start.</p><button onClick={()=>setIsNewProjectModalOpen(true)} className="mt-4 bg-indigo-600 text-white px-6 py-2 rounded">Create Project</button></div> : 
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 flex-1 overflow-x-auto">
                        <Column title="To Do" status={TaskStatus.TODO} tasks={projectTasks.filter(t=>t.status===TaskStatus.TODO)} />
                        <Column title="In Progress" status={TaskStatus.IN_PROGRESS} tasks={projectTasks.filter(t=>t.status===TaskStatus.IN_PROGRESS)} />
                        <Column title="Done" status={TaskStatus.DONE} tasks={projectTasks.filter(t=>t.status===TaskStatus.DONE)} />
                    </div>}
                    <Modal isOpen={isNewProjectModalOpen} onClose={()=>setIsNewProjectModalOpen(false)} title="New Project">
                        <form onSubmit={(e)=>{e.preventDefault();addProject(newProjectName, newProjectDescription);setIsNewProjectModalOpen(false);}} className="space-y-4">
                            <div><label className="block text-sm mb-1">Name</label><input required className="w-full border p-2 rounded" value={newProjectName} onChange={e=>setNewProjectName(e.target.value)}/></div>
                            <div><label className="block text-sm mb-1">Description</label><textarea className="w-full border p-2 rounded" value={newProjectDescription} onChange={e=>setNewProjectDescription(e.target.value)}/></div>
                            <button className="bg-indigo-600 text-white px-4 py-2 rounded w-full">Create</button>
                        </form>
                    </Modal>
                    {/* TaskEditor Mockup - Full implementation would be similar to above but condensed for single file */}
                    {(editingTask || isNewTaskModalOpen) && (
                         <div className="fixed inset-0 z-50 bg-black/50 flex items-center justify-center p-4">
                             <div className="bg-white p-6 rounded-xl w-full max-w-2xl h-[80vh] overflow-y-auto">
                                 <div className="flex justify-between mb-4"><h2 className="text-xl font-bold">{editingTask ? 'Edit Task' : 'New Task'}</h2><button onClick={()=>{setEditingTask(null);setIsNewTaskModalOpen(false);}}><X/></button></div>
                                 <p className="text-slate-400 text-sm text-center">Task Editor UI Simplified for Integration</p>
                                 {/* In a real scenario, full TaskEditor code goes here. For this demo, we just close it. */}
                                 <div className="mt-4 flex justify-end"><button onClick={()=>{setEditingTask(null);setIsNewTaskModalOpen(false);}} className="bg-indigo-600 text-white px-4 py-2 rounded">Close</button></div>
                             </div>
                         </div>
                    )}
                </div>
            );
        };

        // --- MODULE: COMMUNICATION ---
        const Communication = () => {
            const { messages, addMessage, currentUser, users, groups, createGroup, markChatRead, getUnreadCount, startCall, startGroupCall, addToCall, endCall, isInCall, activeCallData, localStream, remoteStreams, isScreenSharing, toggleScreenShare, isMicOn, isCameraOn, toggleMic, toggleCamera } = useApp();
            const [selectedChat, setSelectedChat] = useState(null);
            const [inputText, setInputText] = useState('');
            const [isInviteModalOpen, setIsInviteModalOpen] = useState(false);
            const localVideoRef = useRef(null);
            
            useEffect(() => {
                if (localVideoRef.current) localVideoRef.current.srcObject = localStream;
            }, [localStream, isInCall, isCameraOn]);

            const currentMessages = messages.filter(m => {
                if (!selectedChat) return !m.recipientId;
                if (selectedChat.memberIds) return m.recipientId === selectedChat.id;
                return (m.senderId === currentUser.id && m.recipientId === selectedChat.id) || (m.senderId === selectedChat.id && m.recipientId === currentUser.id);
            });

            const handleSend = (e) => {
                e.preventDefault();
                if (inputText.trim()) { addMessage(inputText, selectedChat?.id); setInputText(''); }
            };

            const handleStartCall = (video) => {
                if (selectedChat && selectedChat.username) {
                    startCall(selectedChat.id, video);
                } else {
                    let recipients = [];
                    if (!selectedChat) recipients = users.filter(u => u.id !== currentUser.id).map(u => u.id);
                    else if (selectedChat.memberIds) recipients = selectedChat.memberIds.filter(id => id !== currentUser.id);
                    if (recipients.length > 0) startGroupCall(recipients, video);
                }
            };

            const RemoteVideoPlayer = ({ stream }) => {
                const vidRef = useRef(null);
                useEffect(() => { if (vidRef.current) vidRef.current.srcObject = stream; }, [stream]);
                return <video ref={vidRef} autoPlay playsInline className="w-full h-full object-cover" />;
            };

            return (
                <div className="flex h-full m-6 bg-white rounded-xl shadow border border-slate-200 overflow-hidden relative">
                    {isInCall && (
                        <div className="absolute inset-0 z-50 bg-slate-900 flex flex-col">
                            <div className="flex-1 grid grid-cols-2 gap-2 p-4">
                                <div className="relative bg-slate-800 rounded overflow-hidden">
                                    <video ref={localVideoRef} autoPlay muted playsInline className={`w-full h-full object-cover ${!isCameraOn?'hidden':''}`}/>
                                    {!isCameraOn && <div className="absolute inset-0 flex items-center justify-center text-white">Camera Off</div>}
                                    <div className="absolute bottom-2 left-2 text-white bg-black/50 px-2 rounded">You</div>
                                </div>
                                {activeCallData?.participantIds.map(pid => (
                                    <div key={pid} className="relative bg-slate-800 rounded overflow-hidden">
                                        {remoteStreams.get(pid) ? <RemoteVideoPlayer stream={remoteStreams.get(pid)}/> : <div className="flex items-center justify-center h-full text-white">Connecting...</div>}
                                    </div>
                                ))}
                            </div>
                            <div className="h-16 bg-black/50 flex justify-center items-center space-x-4">
                                <button onClick={toggleMic} className={`p-3 rounded-full ${!isMicOn?'bg-red-500':'bg-slate-700'} text-white`}>{!isMicOn?<MicOff/>:<Mic/>}</button>
                                <button onClick={toggleCamera} className={`p-3 rounded-full ${!isCameraOn?'bg-red-500':'bg-slate-700'} text-white`}>{!isCameraOn?<VideoOff/>:<Video/>}</button>
                                <button onClick={toggleScreenShare} className={`p-3 rounded-full ${isScreenSharing?'bg-blue-500':'bg-slate-700'} text-white`}><Monitor/></button>
                                <button onClick={()=>setIsInviteModalOpen(true)} className="p-3 rounded-full bg-indigo-600 text-white"><UserPlus/></button>
                                <button onClick={endCall} className="p-3 rounded-full bg-red-600 text-white"><PhoneOff/></button>
                            </div>
                            <Modal isOpen={isInviteModalOpen} onClose={()=>setIsInviteModalOpen(false)} title="Invite">
                                {users.filter(u => u.id !== currentUser.id && !activeCallData.participantIds.includes(u.id)).map(u => (
                                    <div key={u.id} className="flex justify-between p-2 border-b"><span className="font-bold">{u.name}</span><button onClick={()=>{addToCall(u.id);setIsInviteModalOpen(false);}} className="text-indigo-600"><Plus/></button></div>
                                ))}
                            </Modal>
                        </div>
                    )}
                    <div className="w-80 bg-slate-50 border-r flex flex-col">
                        <div className="p-4 border-b font-bold">Chats</div>
                        <div className="flex-1 overflow-y-auto">
                            <button onClick={()=>setSelectedChat(null)} className={`w-full p-3 text-left ${selectedChat===null?'bg-indigo-50 text-indigo-700':''}`}>Team Chat {getUnreadCount('general')>0 && <span className="bg-red-500 text-white text-xs px-1 rounded-full">{getUnreadCount('general')}</span>}</button>
                            {users.filter(u=>u.id!==currentUser.id).map(u => (
                                <button key={u.id} onClick={()=>setSelectedChat(u)} className={`w-full p-3 text-left flex items-center ${selectedChat?.id===u.id?'bg-indigo-50 text-indigo-700':''}`}>
                                    <img src={u.avatar} className="w-8 h-8 rounded-full mr-2"/>
                                    <div><div className="font-medium">{u.name}</div><div className="text-xs text-slate-500">{u.isOnline?'Online':'Offline'}</div></div>
                                </button>
                            ))}
                        </div>
                    </div>
                    <div className="flex-1 flex flex-col">
                        <div className="h-16 border-b flex justify-between items-center px-4">
                            <span className="font-bold">{selectedChat ? selectedChat.name : "Team Chat"}</span>
                            <div className="flex space-x-2"><button onClick={()=>handleStartCall(false)} className="p-2 text-slate-500 hover:text-indigo-600"><Phone/></button><button onClick={()=>handleStartCall(true)} className="p-2 text-slate-500 hover:text-indigo-600"><Video/></button></div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-slate-50/50">
                            {currentMessages.map(m => (
                                <div key={m.id} className={`flex ${m.senderId===currentUser.id?'justify-end':'justify-start'}`}>
                                    <div className={`p-3 rounded-lg max-w-xs ${m.senderId===currentUser.id?'bg-indigo-600 text-white':'bg-white border'}`}>
                                        <div className="text-xs opacity-75 mb-1">{users.find(u=>u.id===m.senderId)?.name}</div>
                                        {m.text}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <form onSubmit={handleSend} className="p-4 border-t flex space-x-2">
                            <input value={inputText} onChange={e=>setInputText(e.target.value)} className="flex-1 border rounded px-3" placeholder="Type a message..."/>
                            <button className="bg-indigo-600 text-white p-2 rounded"><Send/></button>
                        </form>
                    </div>
                </div>
            );
        };

        // --- APP SHELL ---
        const IncomingCallOverlay = () => {
            const { incomingCall, users, acceptIncomingCall, rejectIncomingCall } = useApp();
            if (!incomingCall) return null;
            const caller = users.find(u => u.id === incomingCall.callerId);
            return (
                <div className="fixed inset-0 z-[100] bg-black/80 flex flex-col items-center justify-center text-white">
                    <img src={caller?.avatar} className="w-32 h-32 rounded-full mb-4 animate-bounce"/>
                    <h2 className="text-2xl font-bold mb-8">Incoming Call from {caller?.name}</h2>
                    <div className="flex space-x-8">
                        <button onClick={rejectIncomingCall} className="bg-red-500 p-4 rounded-full"><PhoneOff size={32}/></button>
                        <button onClick={acceptIncomingCall} className="bg-green-500 p-4 rounded-full"><Phone size={32}/></button>
                    </div>
                </div>
            );
        };

        const MainLayout = () => {
            const { currentUser, logout, notifications, clearNotifications } = useApp();
            const [activeTab, setActiveTab] = useState('dashboard');
            
            if (!currentUser) return <Login />;
            
            return (
                <div className="flex h-screen bg-slate-50">
                    <IncomingCallOverlay />
                    <aside className="w-64 bg-slate-900 text-white flex flex-col">
                        <div className="p-6 text-xl font-bold border-b border-slate-800">Nexus PM</div>
                        <nav className="flex-1 p-3 space-y-1">
                            <button onClick={()=>setActiveTab('dashboard')} className={`w-full flex items-center p-3 rounded ${activeTab==='dashboard'?'bg-indigo-600':'hover:bg-slate-800'}`}><LayoutDashboard className="mr-3"/> Dashboard</button>
                            <button onClick={()=>setActiveTab('projects')} className={`w-full flex items-center p-3 rounded ${activeTab==='projects'?'bg-indigo-600':'hover:bg-slate-800'}`}><KanbanSquare className="mr-3"/> Projects</button>
                            <button onClick={()=>setActiveTab('chat')} className={`w-full flex items-center p-3 rounded ${activeTab==='chat'?'bg-indigo-600':'hover:bg-slate-800'}`}><MessageSquare className="mr-3"/> Team Chat</button>
                        </nav>
                        <div className="p-4 border-t border-slate-800">
                             <div className="flex items-center mb-4"><img src={currentUser.avatar} className="w-8 h-8 rounded-full mr-2"/><span className="font-bold">{currentUser.name}</span></div>
                             <button onClick={logout} className="w-full flex items-center justify-center p-2 border border-slate-700 rounded hover:bg-slate-800"><LogOut size={16} className="mr-2"/> Logout</button>
                        </div>
                    </aside>
                    <main className="flex-1 overflow-hidden flex flex-col">
                        <div className="flex-1 overflow-auto">
                            {activeTab === 'dashboard' && <Dashboard />}
                            {activeTab === 'projects' && <KanbanBoard />}
                            {activeTab === 'chat' && <Communication />}
                        </div>
                    </main>
                </div>
            );
        };

        const App = () => (
            <AppProvider>
                <MainLayout />
            </AppProvider>
        );

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
